<!DOCTYPE html>
<html lang="en">
<head>
    <title>The In-Between</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        * { margin: 0; padding: 0; }
        body {
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Georgia', serif;
        }
        #whisper {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            font-style: italic;
            letter-spacing: 2px;
            text-align: center;
            pointer-events: none;
            transition: opacity 2s ease;
            max-width: 80%;
        }
        #memory-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0);
            font-size: 18px;
            font-style: italic;
            letter-spacing: 3px;
            text-align: center;
            pointer-events: none;
            transition: opacity 1.5s ease, transform 1.5s ease;
            max-width: 60%;
            line-height: 1.8;
        }
        #memory-text.visible {
            opacity: 0.7;
            transform: translate(-50%, -50%) scale(1);
        }
        #vignette {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(5, 5, 15, 0.8) 100%);
            z-index: 10;
        }
        #fade-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease;
            z-index: 100;
        }
        #memories-collected {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-size: 12px;
            letter-spacing: 1px;
            pointer-events: none;
        }
        #zoom-indicator {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }
        .zoom-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            transition: all 0.5s ease;
        }
        .zoom-dot.active {
            background: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
        }
        .zoom-label {
            position: absolute;
            left: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            letter-spacing: 1px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .zoom-label.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="vignette"></div>
    <div id="fade-overlay"></div>
    <div id="whisper">somewhere between sleep and waking...</div>
    <div id="memory-text"></div>
    <div id="memories-collected"></div>
    <div id="zoom-indicator"></div>
    <div class="zoom-label" id="zoom-label"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls, clock;
        let player, playerLight;
        let water;
        let flowers = [];
        let creatures = [];
        let mysticalElements = [];
        let memoryFragments = [];
        let gardenPlants = [];

        // Scene state
        let currentScene = 'island';
        let isTransitioning = false;

        // World state
        const world = {
            explored: 0,
            memoriesCollected: 0,
            totalMemories: 8,
            gardenGrowth: 0,
            atmosphere: 'twilight', // twilight, dawn, starfall
            visitedAreas: new Set()
        };

        // Memory fragments - story pieces
        const memories = [
            { text: "I remember... a voice calling my name", collected: false },
            { text: "There was warmth here once... wasn't there?", collected: false },
            { text: "The stars looked different then", collected: false },
            { text: "Someone was waiting... or was I the one waiting?", collected: false },
            { text: "This tree... I've rested here before", collected: false },
            { text: "The water remembers everything we forget", collected: false },
            { text: "Time moves strangely in dreams", collected: false },
            { text: "I think I'm starting to remember why I'm here", collected: false }
        ];

        // Player state
        const playerState = {
            position: new THREE.Vector3(0, 1.5, 0),
            targetPosition: new THREE.Vector3(0, 1.5, 0),
            mood: 'calm', // calm, curious, nostalgic, peaceful
            lastInteraction: 0
        };

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let mouseDown = false;

        // Zoom perspective system - Scene Levels:
        // Level 1: Spirit View - close behind the light orb
        // Level 2: Companion - following at a comfortable distance
        // Level 3: Observer - the default view
        // Level 4: Overseer - bird's eye view of the island
        // Level 5: Ascent - passing through the clouds
        // Level 6: Departure - triggers transition to Orbit scene
        //
        // Scenes: Island, Tower, Orbit, Solar System
        const zoomLevels = [
            { name: 'spirit', distance: 1.5, height: 1.8, fov: 80, polar: Math.PI / 2.2, whisper: 'seeing through spirit...' },
            { name: 'companion', distance: 8, height: 4, fov: 65, polar: Math.PI / 3, whisper: '' },
            { name: 'observer', distance: 25, height: 20, fov: 60, polar: Math.PI / 4, whisper: '' },
            { name: 'overseer', distance: 60, height: 55, fov: 50, polar: Math.PI / 6, whisper: 'the island feels so small from here...' },
            { name: 'ascent', distance: 120, height: 110, fov: 45, polar: Math.PI / 8, whisper: 'passing through the clouds...' },
            { name: 'departure', distance: 250, height: 200, fov: 35, polar: Math.PI / 10, whisper: '' } // triggers Orbit scene
        ];
        let currentZoomLevel = 2; // Start at 'observer'
        let targetZoom = zoomLevels[currentZoomLevel];
        let zoomTransitioning = false;
        let zoomProgress = 1;
        let currentZoomState = { ...zoomLevels[2] };
        let zoomScrollAccumulator = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x2a3a4a, 0.004);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 25);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x3a4a5a);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 300;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.target.set(0, 0, 0);
            controls.enableZoom = false; // We'll handle zoom ourselves

            // Custom zoom system with perspective levels
            setupZoomSystem();

            buildIslandScene();

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', (e) => { mouseDown = true; updateTarget(e); });
            window.addEventListener('mouseup', () => mouseDown = false);
            window.addEventListener('mousemove', (e) => { if (mouseDown) updateTarget(e); });
            window.addEventListener('click', updateTarget);

            setTimeout(() => {
                document.getElementById('whisper').style.opacity = '0';
            }, 4000);

            updateMemoryCounter();
        }

        function updateMemoryCounter() {
            const el = document.getElementById('memories-collected');
            if (world.memoriesCollected > 0) {
                el.textContent = `memories: ${world.memoriesCollected} / ${world.totalMemories}`;
                el.style.opacity = '1';
            }
        }

        function showMemoryText(text) {
            const el = document.getElementById('memory-text');
            el.textContent = text;
            el.classList.add('visible');
            setTimeout(() => {
                el.classList.remove('visible');
            }, 4000);
        }

        function setWhisper(text) {
            const el = document.getElementById('whisper');
            el.textContent = text;
            el.style.opacity = '0.4';
            setTimeout(() => { el.style.opacity = '0'; }, 4000);
        }

        function setupZoomSystem() {
            // Create zoom indicator dots
            const indicator = document.getElementById('zoom-indicator');
            zoomLevels.forEach((level, i) => {
                const dot = document.createElement('div');
                dot.className = 'zoom-dot' + (i === currentZoomLevel ? ' active' : '');
                dot.dataset.index = i;
                indicator.appendChild(dot);
            });

            window.addEventListener('wheel', (e) => {
                if (isTransitioning) return;

                // Handle orbit scene - scroll out to solar system, scroll in to return
                if (currentScene === 'orbit') {
                    e.preventDefault();
                    zoomScrollAccumulator += e.deltaY;
                    if (zoomScrollAccumulator > 200) {
                        zoomScrollAccumulator = 0;
                        transitionToScene('solar');
                    } else if (zoomScrollAccumulator < -200) {
                        zoomScrollAccumulator = 0;
                        transitionToScene('island');
                    }
                    return;
                }

                // Handle solar scene - scroll in to return
                if (currentScene === 'solar') {
                    e.preventDefault();
                    zoomScrollAccumulator += e.deltaY;
                    if (zoomScrollAccumulator < -200) {
                        zoomScrollAccumulator = 0;
                        transitionToScene('orbit');
                    }
                    return;
                }

                if (currentScene !== 'island') return;

                e.preventDefault();

                // Accumulate scroll
                zoomScrollAccumulator += e.deltaY;

                // Threshold to change level
                const threshold = 150;

                if (Math.abs(zoomScrollAccumulator) > threshold) {
                    const direction = zoomScrollAccumulator > 0 ? 1 : -1;
                    const newLevel = Math.max(0, Math.min(zoomLevels.length - 1, currentZoomLevel + direction));

                    if (newLevel !== currentZoomLevel) {
                        currentZoomLevel = newLevel;
                        targetZoom = zoomLevels[currentZoomLevel];
                        zoomTransitioning = true;
                        zoomProgress = 0;

                        // Update indicator
                        updateZoomIndicator();

                        // Show whisper for special zoom levels
                        if (targetZoom.whisper) {
                            setWhisper(targetZoom.whisper);
                        }

                        // Trigger orbit transition when reaching departure
                        if (targetZoom.name === 'departure') {
                            setTimeout(() => {
                                transitionToScene('orbit');
                            }, 800);
                        }
                    }

                    zoomScrollAccumulator = 0;
                }
            }, { passive: false });
        }

        function updateZoomIndicator() {
            const dots = document.querySelectorAll('.zoom-dot');
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === currentZoomLevel);
            });

            // Show label briefly
            const label = document.getElementById('zoom-label');
            const labelNames = ['spirit', 'companion', 'observer', 'overseer', 'ascent', 'departure'];
            label.textContent = labelNames[currentZoomLevel];
            label.style.top = `calc(50% - ${(zoomLevels.length / 2 - currentZoomLevel) * 16}px)`;
            label.classList.add('visible');

            clearTimeout(label.hideTimeout);
            label.hideTimeout = setTimeout(() => {
                label.classList.remove('visible');
            }, 2000);
        }

        function updateZoom(delta) {
            if (!zoomTransitioning) return;

            // Smooth transition
            zoomProgress += delta * 0.8; // Speed of transition

            if (zoomProgress >= 1) {
                zoomProgress = 1;
                zoomTransitioning = false;
                currentZoomState = { ...targetZoom };
            }

            // Easing function (smooth step)
            const t = zoomProgress;
            const ease = t * t * (3 - 2 * t);

            // Interpolate all values
            currentZoomState.distance = THREE.MathUtils.lerp(currentZoomState.distance, targetZoom.distance, ease);
            currentZoomState.height = THREE.MathUtils.lerp(currentZoomState.height, targetZoom.height, ease);
            currentZoomState.fov = THREE.MathUtils.lerp(currentZoomState.fov, targetZoom.fov, ease);
            currentZoomState.polar = THREE.MathUtils.lerp(currentZoomState.polar, targetZoom.polar, ease);

            // Update FOV
            camera.fov = currentZoomState.fov;
            camera.updateProjectionMatrix();
        }

        function applyZoomToCamera() {
            if (currentScene !== 'island') return;

            const target = player ? player.position.clone() : new THREE.Vector3(0, 0, 0);

            // Calculate camera position based on zoom state
            const horizontalDist = Math.cos(currentZoomState.polar) * currentZoomState.distance;
            const verticalDist = Math.sin(currentZoomState.polar) * currentZoomState.distance;

            // Get current camera angle around Y axis
            const currentAngle = Math.atan2(
                camera.position.x - target.x,
                camera.position.z - target.z
            );

            const targetCamPos = new THREE.Vector3(
                target.x + Math.sin(currentAngle) * horizontalDist,
                target.y + currentZoomState.height,
                target.z + Math.cos(currentAngle) * horizontalDist
            );

            // Smooth camera movement
            camera.position.lerp(targetCamPos, 0.05);

            // First person - camera just behind and slightly above player, looking where they look
            if (currentZoomLevel === 0) {
                // Camera stays close behind player
                controls.enabled = true;
                controls.maxPolarAngle = Math.PI / 2.1;
                controls.minPolarAngle = Math.PI / 6;
            } else {
                controls.enabled = true;
                controls.maxPolarAngle = Math.PI / 2.1;
                controls.minPolarAngle = 0;
            }
        }

        // ============================================
        // ISLAND SCENE
        // ============================================
        function buildIslandScene() {
            flowers = [];
            creatures = [];
            mysticalElements = [];
            memoryFragments = [];
            gardenPlants = [];

            // Sky with subtle gradient
            const skyGeom = new THREE.SphereGeometry(200, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    atmosphere: { value: 0.3 },
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vPos;
                    void main() {
                        vPos = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float atmosphere;
                    uniform float time;
                    varying vec3 vPos;
                    void main() {
                        float h = normalize(vPos).y;
                        vec3 horizon = mix(vec3(0.25, 0.2, 0.35), vec3(0.35, 0.25, 0.3), atmosphere);
                        vec3 zenith = mix(vec3(0.1, 0.12, 0.25), vec3(0.15, 0.1, 0.2), atmosphere);
                        vec3 color = mix(horizon, zenith, pow(max(h, 0.0), 0.5));
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeom, skyMat);
            sky.userData.type = 'sky';
            scene.add(sky);

            // Stars - more of them, twinkling
            const starGeom = new THREE.BufferGeometry();
            const starPositions = [];
            const starSizes = [];
            for (let i = 0; i < 600; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 0.85 + 0.15);
                const r = 180;
                starPositions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
                starSizes.push(Math.random());
            }
            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeom.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            const starMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    attribute float size;
                    varying float vSize;
                    void main() {
                        vSize = size;
                        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.5 + size * 2.0) * (200.0 / -mvPos.z);
                        gl_Position = projectionMatrix * mvPos;
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying float vSize;
                    void main() {
                        float d = length(gl_PointCoord - 0.5);
                        if (d > 0.5) discard;
                        float twinkle = 0.5 + 0.5 * sin(time * (2.0 + vSize * 3.0) + vSize * 20.0);
                        float alpha = (1.0 - d * 2.0) * 0.6 * twinkle;
                        gl_FragColor = vec4(0.9, 0.85, 1.0, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            const stars = new THREE.Points(starGeom, starMat);
            stars.userData.type = 'stars';
            scene.add(stars);

            // Lighting
            scene.add(new THREE.AmbientLight(0x8899aa, 1.2));
            scene.add(new THREE.HemisphereLight(0xaabbcc, 0x667788, 0.8));
            const dirLight = new THREE.DirectionalLight(0xccddee, 1.4);
            dirLight.position.set(20, 40, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);

            // Main island - slightly larger
            const islandGeom = new THREE.CylinderGeometry(16, 14, 5, 32);
            const islandMat = new THREE.MeshStandardMaterial({ color: 0x4a6045, roughness: 0.9 });
            const island = new THREE.Mesh(islandGeom, islandMat);
            island.position.y = -2.5;
            island.receiveShadow = true;
            scene.add(island);

            // Grass with slight variation
            const grassGeom = new THREE.CircleGeometry(16, 64);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x5a7a5a, roughness: 1.0 });
            const grass = new THREE.Mesh(grassGeom, grassMat);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = 0.01;
            grass.receiveShadow = true;
            grass.userData.isGround = true;
            scene.add(grass);

            // Water - darker, more mysterious
            const waterGeom = new THREE.PlaneGeometry(500, 500, 50, 50);
            const waterMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        pos.z += sin(pos.x * 0.05 + time * 0.5) * 0.5;
                        pos.z += sin(pos.y * 0.07 + time * 0.3) * 0.3;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vec3 deep = vec3(0.02, 0.04, 0.08);
                        vec3 surface = vec3(0.05, 0.08, 0.12);
                        float shimmer = sin(vUv.x * 100.0 + time) * sin(vUv.y * 100.0 + time * 0.7) * 0.5 + 0.5;
                        vec3 color = mix(deep, surface, shimmer * 0.2);
                        gl_FragColor = vec4(color, 0.95);
                    }
                `,
                transparent: true
            });
            water = new THREE.Mesh(waterGeom, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -3.5;
            water.userData.type = 'water';
            scene.add(water);

            // Player
            createPlayer();

            // Flowers - scattered naturally
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 2 + Math.random() * 12;
                createFlower(Math.cos(angle) * r, Math.sin(angle) * r);
            }

            // Creatures - gentle spirits
            for (let i = 0; i < 6; i++) {
                createCreature();
            }

            // Core mystical elements
            createHummingTree(-6, 5);
            createReflectivePond(7, -4);
            createWarmStone(-4, -7);
            createCastleTower(0, 10);

            // Memory fragments scattered around
            createMemoryFragment(8, 0, 0);
            createMemoryFragment(-10, 0, 2);
            createMemoryFragment(3, 0, -9);
            createMemoryFragment(-7, 0, -5);
            createMemoryFragment(5, 0, 8);

            // The Dream Garden - hidden area that grows
            createDreamGarden(-10, -8);

            // Forgotten Shore - edge of the island
            createForgottenShore(12, 0);

            // Floating stones - ambient decoration
            for (let i = 0; i < 5; i++) {
                createFloatingStone();
            }

            // Ancient arch - mysterious structure
            createAncientArch(10, 6);
        }

        function createPlayer() {
            const group = new THREE.Group();

            // Core - brighter
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            group.add(core);

            // Inner glow
            const inner = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0.4 })
            );
            group.add(inner);

            // Outer aura
            const outer = new THREE.Mesh(
                new THREE.SphereGeometry(0.9, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x6699cc, transparent: true, opacity: 0.15 })
            );
            group.add(outer);

            playerLight = new THREE.PointLight(0xaaccff, 2.5, 18);
            group.add(playerLight);

            group.position.copy(playerState.position);
            player = group;
            scene.add(player);
        }

        function createFlower(x, z) {
            const group = new THREE.Group();

            const stemHeight = 0.3 + Math.random() * 0.2;
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.025, stemHeight, 6),
                new THREE.MeshStandardMaterial({ color: 0x2a4a2a })
            );
            stem.position.y = stemHeight / 2;
            group.add(stem);

            const colors = [0xffaacc, 0xaaccff, 0xccaaff, 0xffccaa, 0xaaffcc, 0xffaaaa];
            const color = colors[Math.floor(Math.random() * colors.length)];

            const petalGroup = new THREE.Group();
            petalGroup.position.y = stemHeight;

            const petalCount = 4 + Math.floor(Math.random() * 3);
            for (let i = 0; i < petalCount; i++) {
                const petal = new THREE.Mesh(
                    new THREE.SphereGeometry(0.06 + Math.random() * 0.03, 6, 6),
                    new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.1 })
                );
                const a = (i / petalCount) * Math.PI * 2;
                petal.position.set(Math.cos(a) * 0.04, 0, Math.sin(a) * 0.04);
                petal.scale.set(1, 0.3, 0.5);
                petal.userData.baseAngle = a;
                petalGroup.add(petal);
            }
            group.add(petalGroup);

            const center = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 6, 6),
                new THREE.MeshBasicMaterial({ color: 0xffffaa })
            );
            center.position.y = stemHeight;
            group.add(center);

            group.position.set(x, 0, z);
            group.userData = { type: 'flower', bloom: 0, petalGroup };
            flowers.push(group);
            scene.add(group);
        }

        function createCreature() {
            const group = new THREE.Group();
            const hue = Math.random();
            const color = new THREE.Color().setHSL(hue, 0.6, 0.65);

            // Soft body
            const body = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 12, 12),
                new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.75 })
            );
            group.add(body);

            // Tiny sparkle core
            const sparkle = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 })
            );
            group.add(sparkle);

            group.add(new THREE.PointLight(color, 0.4, 4));

            const angle = Math.random() * Math.PI * 2;
            const r = 3 + Math.random() * 10;
            group.position.set(Math.cos(angle) * r, 0.8 + Math.random() * 1.5, Math.sin(angle) * r);

            group.userData = {
                type: 'creature',
                baseY: group.position.y,
                driftTarget: group.position.clone(),
                driftTimer: Math.random() * 3,
                speed: 0.15 + Math.random() * 0.15,
                personality: Math.random() // affects behavior
            };

            creatures.push(group);
            scene.add(group);
        }

        function createHummingTree(x, z) {
            const group = new THREE.Group();

            // Trunk - gnarled
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.25, 0.5, 3.5, 8),
                new THREE.MeshStandardMaterial({ color: 0x2a1a1a, roughness: 1 })
            );
            trunk.position.y = 1.75;
            trunk.castShadow = true;
            group.add(trunk);

            // Canopy - ethereal
            const canopy = new THREE.Mesh(
                new THREE.SphereGeometry(2.5, 16, 16),
                new THREE.MeshStandardMaterial({
                    color: 0x223322,
                    emissive: 0x112211,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.9
                })
            );
            canopy.position.y = 4;
            canopy.scale.set(1, 0.7, 1);
            group.add(canopy);

            // Glowing leaves/particles around tree
            for (let i = 0; i < 8; i++) {
                const leaf = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x88ff88, transparent: true, opacity: 0.6 })
                );
                const a = Math.random() * Math.PI * 2;
                const r = 1.5 + Math.random();
                const h = 3 + Math.random() * 2;
                leaf.position.set(Math.cos(a) * r, h, Math.sin(a) * r);
                leaf.userData.orbitAngle = a;
                leaf.userData.orbitRadius = r;
                leaf.userData.orbitHeight = h;
                leaf.userData.orbitSpeed = 0.2 + Math.random() * 0.3;
                group.add(leaf);
            }

            // Soft light
            const treeLight = new THREE.PointLight(0x88ff88, 0.5, 8);
            treeLight.position.y = 4;
            group.add(treeLight);

            group.position.set(x, 0, z);
            group.userData = { type: 'hummingTree', canopy, treeLight };
            mysticalElements.push(group);
            scene.add(group);
        }

        function createReflectivePond(x, z) {
            const group = new THREE.Group();

            // Stone ring
            for (let i = 0; i < 14; i++) {
                const a = (i / 14) * Math.PI * 2 + Math.random() * 0.2;
                const stone = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35 + Math.random() * 0.25, 0.15 + Math.random() * 0.1, 0.35 + Math.random() * 0.25),
                    new THREE.MeshStandardMaterial({ color: 0x556666, roughness: 0.9 })
                );
                stone.position.set(Math.cos(a) * 2.5, 0.08, Math.sin(a) * 2.5);
                stone.rotation.y = a + Math.random();
                group.add(stone);
            }

            // Pond surface - reflective
            const pond = new THREE.Mesh(
                new THREE.CircleGeometry(2.2, 32),
                new THREE.ShaderMaterial({
                    uniforms: { time: { value: 0 } },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec2 vUv;
                        void main() {
                            vec2 c = vUv - 0.5;
                            float d = length(c);
                            float ripple = sin(d * 15.0 - time * 2.0) * 0.5 + 0.5;
                            ripple *= smoothstep(0.5, 0.2, d);
                            vec3 deep = vec3(0.08, 0.04, 0.15);
                            vec3 glow = vec3(0.2, 0.15, 0.3) * ripple * 0.4;
                            float edge = smoothstep(0.5, 0.45, d);
                            gl_FragColor = vec4(deep + glow, edge * 0.95);
                        }
                    `,
                    transparent: true
                })
            );
            pond.rotation.x = -Math.PI / 2;
            pond.position.y = 0.02;
            pond.userData.type = 'pondSurface';
            group.add(pond);

            // Subtle glow from depths
            const pondLight = new THREE.PointLight(0x6644aa, 0.3, 4);
            pondLight.position.y = -0.5;
            group.add(pondLight);

            group.position.set(x, 0, z);
            group.userData = { type: 'reflectivePond', pond, pondLight };
            mysticalElements.push(group);
            scene.add(group);
        }

        function createWarmStone(x, z) {
            const group = new THREE.Group();

            const stone = new THREE.Mesh(
                new THREE.DodecahedronGeometry(0.9, 1),
                new THREE.MeshStandardMaterial({
                    color: 0x5a4a4a,
                    emissive: 0xff4400,
                    emissiveIntensity: 0.25,
                    roughness: 0.8
                })
            );
            stone.scale.set(1.3, 0.6, 1);
            stone.position.y = 0.35;
            stone.castShadow = true;
            group.add(stone);

            // Inner glow
            const innerGlow = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xff6633, transparent: true, opacity: 0.3 })
            );
            innerGlow.position.y = 0.35;
            group.add(innerGlow);

            const light = new THREE.PointLight(0xff6633, 1.2, 7);
            light.position.y = 0.5;
            group.add(light);

            // Ground glow
            const groundGlow = new THREE.Mesh(
                new THREE.CircleGeometry(1.8, 32),
                new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.15 })
            );
            groundGlow.rotation.x = -Math.PI / 2;
            groundGlow.position.y = 0.02;
            group.add(groundGlow);

            group.position.set(x, 0, z);
            group.userData = { type: 'warmStone', stone, innerGlow, light, groundGlow };
            mysticalElements.push(group);
            scene.add(group);
        }

        function createCastleTower(x, z) {
            const group = new THREE.Group();

            // Tower body
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(1.6, 2, 7, 8),
                new THREE.MeshStandardMaterial({ color: 0x3a3a4a, roughness: 0.95 })
            );
            tower.position.y = 3.5;
            tower.castShadow = true;
            group.add(tower);

            // Stone rings
            for (let i = 0; i < 5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(1.7 - i * 0.02, 0.05, 6, 16),
                    new THREE.MeshStandardMaterial({ color: 0x2a2a3a })
                );
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 1 + i * 1.4;
                group.add(ring);
            }

            // Battlements
            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2;
                const cren = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 0.9, 0.45),
                    new THREE.MeshStandardMaterial({ color: 0x3a3a4a })
                );
                cren.position.set(Math.cos(a) * 1.4, 7.4, Math.sin(a) * 1.4);
                cren.rotation.y = a;
                cren.castShadow = true;
                group.add(cren);
            }

            // Doorway
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.3, 2.8, 0.35),
                new THREE.MeshStandardMaterial({ color: 0x1a1a2a })
            );
            frame.position.set(0, 1.4, 1.85);
            group.add(frame);

            // Portal glow
            const portal = new THREE.Mesh(
                new THREE.PlaneGeometry(1.1, 2.4),
                new THREE.ShaderMaterial({
                    uniforms: { time: { value: 0 } },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec2 vUv;
                        void main() {
                            vec2 c = vUv - 0.5;
                            float d = length(c);
                            float angle = atan(c.y, c.x);
                            float swirl = sin(angle * 3.0 + time * 1.5 + d * 8.0) * 0.5 + 0.5;
                            vec3 c1 = vec3(0.3, 0.2, 0.5);
                            vec3 c2 = vec3(0.5, 0.3, 0.6);
                            vec3 color = mix(c1, c2, swirl);
                            color += vec3(0.2, 0.3, 0.5) * smoothstep(0.5, 0.0, d);
                            float alpha = smoothstep(0.55, 0.3, d) * 0.9;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true
                })
            );
            portal.position.set(0, 1.4, 1.7);
            portal.userData.type = 'towerPortal';
            group.add(portal);

            const portalLight = new THREE.PointLight(0x6688ff, 1.2, 6);
            portalLight.position.set(0, 1.5, 2.2);
            group.add(portalLight);

            // Window
            const windowMesh = new THREE.Mesh(
                new THREE.CircleGeometry(0.35, 16),
                new THREE.MeshBasicMaterial({ color: 0xffaa66 })
            );
            windowMesh.position.set(0, 5, 1.62);
            group.add(windowMesh);

            const windowLight = new THREE.PointLight(0xffaa66, 0.4, 3);
            windowLight.position.set(0, 5, 1.8);
            group.add(windowLight);

            group.position.set(x, 0, z);
            group.userData = {
                type: 'castleTower',
                portal,
                portalPos: new THREE.Vector3(x, 1.4, z + 2)
            };
            mysticalElements.push(group);
            scene.add(group);
        }

        function createMemoryFragment(x, y, z) {
            if (world.memoriesCollected >= memories.length) return;

            const group = new THREE.Group();

            // Core wisp
            const wisp = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xffeedd, transparent: true, opacity: 0.8 })
            );
            group.add(wisp);

            // Outer glow
            const glow = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0xffccaa, transparent: true, opacity: 0.3 })
            );
            group.add(glow);

            // Trail particles (static for now)
            for (let i = 0; i < 5; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0xffeedd, transparent: true, opacity: 0.4 - i * 0.07 })
                );
                particle.position.y = -i * 0.15;
                particle.scale.setScalar(1 - i * 0.15);
                group.add(particle);
            }

            const light = new THREE.PointLight(0xffddaa, 0.6, 4);
            group.add(light);

            group.position.set(x, y + 1.2, z);
            group.userData = {
                type: 'memoryFragment',
                collected: false,
                memoryIndex: memoryFragments.length,
                baseY: y + 1.2,
                bobOffset: Math.random() * Math.PI * 2
            };

            memoryFragments.push(group);
            scene.add(group);
        }

        function createDreamGarden(x, z) {
            const group = new THREE.Group();

            // Garden bed - circular area
            const bed = new THREE.Mesh(
                new THREE.CircleGeometry(3, 32),
                new THREE.MeshStandardMaterial({ color: 0x4a5a4a, roughness: 1 })
            );
            bed.rotation.x = -Math.PI / 2;
            bed.position.y = 0.02;
            bed.userData.isGround = true;
            group.add(bed);

            // Stone border
            for (let i = 0; i < 16; i++) {
                const a = (i / 16) * Math.PI * 2;
                const stone = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15 + Math.random() * 0.1, 6, 6),
                    new THREE.MeshStandardMaterial({ color: 0x667766 })
                );
                stone.position.set(Math.cos(a) * 3, 0.1, Math.sin(a) * 3);
                stone.scale.y = 0.5;
                group.add(stone);
            }

            // Seedling spots - will grow based on exploration
            const seedSpots = [];
            for (let i = 0; i < 7; i++) {
                const a = (i / 7) * Math.PI * 2 + 0.3;
                const r = 1 + Math.random() * 1.5;
                const spot = new THREE.Group();
                spot.position.set(Math.cos(a) * r, 0, Math.sin(a) * r);
                spot.userData = { grown: false, growthStage: 0 };
                seedSpots.push(spot);
                group.add(spot);
            }

            // Central glowing seed
            const seed = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.2),
                new THREE.MeshBasicMaterial({ color: 0xaaffaa, transparent: true, opacity: 0.7 })
            );
            seed.position.y = 0.3;
            group.add(seed);

            const seedLight = new THREE.PointLight(0xaaffaa, 0.4, 4);
            seedLight.position.y = 0.3;
            group.add(seedLight);

            group.position.set(x, 0, z);
            group.userData = { type: 'dreamGarden', seedSpots, seed, seedLight };
            mysticalElements.push(group);
            scene.add(group);
        }

        function createForgottenShore(x, z) {
            const group = new THREE.Group();

            // Sandy patch
            const sand = new THREE.Mesh(
                new THREE.CircleGeometry(2.5, 24),
                new THREE.MeshStandardMaterial({ color: 0x8a8070, roughness: 1 })
            );
            sand.rotation.x = -Math.PI / 2;
            sand.position.y = -0.1;
            sand.userData.isGround = true;
            group.add(sand);

            // Driftwood
            const driftwood = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.12, 1.5, 6),
                new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 1 })
            );
            driftwood.rotation.z = Math.PI / 2 + 0.2;
            driftwood.rotation.y = 0.5;
            driftwood.position.set(0.5, 0.1, 0.3);
            group.add(driftwood);

            // Shells
            for (let i = 0; i < 4; i++) {
                const shell = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 6, 4),
                    new THREE.MeshStandardMaterial({ color: 0xddd8d0 })
                );
                shell.scale.y = 0.3;
                shell.position.set(
                    (Math.random() - 0.5) * 3,
                    0.05,
                    (Math.random() - 0.5) * 3
                );
                group.add(shell);
            }

            // Message in a bottle
            const bottle = new THREE.Group();
            const bottleBody = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.08, 0.3, 8),
                new THREE.MeshStandardMaterial({ color: 0x88aa88, transparent: true, opacity: 0.6, roughness: 0.1 })
            );
            bottle.add(bottleBody);
            const cork = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.05, 0.08, 6),
                new THREE.MeshStandardMaterial({ color: 0x8a6a4a })
            );
            cork.position.y = 0.18;
            bottle.add(cork);
            bottle.rotation.z = Math.PI / 2 - 0.3;
            bottle.position.set(-0.8, 0.1, -0.5);
            bottle.userData.type = 'bottle';
            group.add(bottle);

            // Gentle waves lapping (visual only)
            const waveRing = new THREE.Mesh(
                new THREE.RingGeometry(2.3, 2.8, 32),
                new THREE.MeshBasicMaterial({ color: 0x4466aa, transparent: true, opacity: 0.2, side: THREE.DoubleSide })
            );
            waveRing.rotation.x = -Math.PI / 2;
            waveRing.position.y = -0.05;
            waveRing.userData.type = 'waveRing';
            group.add(waveRing);

            group.position.set(x, 0, z);
            group.userData = { type: 'forgottenShore', waveRing };
            mysticalElements.push(group);
            scene.add(group);
        }

        function createFloatingStone() {
            const stone = new THREE.Mesh(
                new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.3, 0),
                new THREE.MeshStandardMaterial({ color: 0x556666, roughness: 0.9 })
            );

            const angle = Math.random() * Math.PI * 2;
            const r = 8 + Math.random() * 6;
            stone.position.set(
                Math.cos(angle) * r,
                2 + Math.random() * 3,
                Math.sin(angle) * r
            );

            stone.userData = {
                type: 'floatingStone',
                baseY: stone.position.y,
                bobSpeed: 0.3 + Math.random() * 0.3,
                bobOffset: Math.random() * Math.PI * 2,
                rotSpeed: (Math.random() - 0.5) * 0.2
            };

            scene.add(stone);
        }

        function createAncientArch(x, z) {
            const group = new THREE.Group();

            // Left pillar
            const leftPillar = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 4, 0.6),
                new THREE.MeshStandardMaterial({ color: 0x5a5a6a, roughness: 0.95 })
            );
            leftPillar.position.set(-1.2, 2, 0);
            leftPillar.castShadow = true;
            group.add(leftPillar);

            // Right pillar
            const rightPillar = leftPillar.clone();
            rightPillar.position.set(1.2, 2, 0);
            group.add(rightPillar);

            // Arch top
            const archGeom = new THREE.TorusGeometry(1.2, 0.3, 8, 16, Math.PI);
            const arch = new THREE.Mesh(
                archGeom,
                new THREE.MeshStandardMaterial({ color: 0x5a5a6a, roughness: 0.95 })
            );
            arch.rotation.z = Math.PI;
            arch.rotation.y = Math.PI / 2;
            arch.position.y = 4;
            arch.castShadow = true;
            group.add(arch);

            // Runes (glowing marks)
            const runePositions = [
                { x: -1.2, y: 2.5, z: 0.31 },
                { x: -1.2, y: 1.5, z: 0.31 },
                { x: 1.2, y: 2.5, z: 0.31 },
                { x: 1.2, y: 1.5, z: 0.31 }
            ];

            runePositions.forEach(pos => {
                const rune = new THREE.Mesh(
                    new THREE.CircleGeometry(0.12, 6),
                    new THREE.MeshBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.6 })
                );
                rune.position.set(pos.x, pos.y, pos.z);
                group.add(rune);
            });

            // Portal shimmer between pillars
            const shimmer = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 3.5),
                new THREE.MeshBasicMaterial({ color: 0x6688aa, transparent: true, opacity: 0.05 })
            );
            shimmer.position.y = 2;
            shimmer.userData.type = 'archShimmer';
            group.add(shimmer);

            group.position.set(x, 0, z);
            group.rotation.y = -0.3;
            group.userData = { type: 'ancientArch', shimmer };
            mysticalElements.push(group);
            scene.add(group);
        }

        // ============================================
        // TOWER SCENE
        // ============================================
        function buildTowerScene() {
            flowers = [];
            creatures = [];
            mysticalElements = [];
            memoryFragments = [];
            gardenPlants = [];

            scene.add(new THREE.AmbientLight(0x556677, 0.8));

            // Floor
            const floor = new THREE.Mesh(
                new THREE.CircleGeometry(9, 32),
                new THREE.MeshStandardMaterial({ color: 0x2a2a3a, roughness: 0.9 })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.userData.isGround = true;
            scene.add(floor);

            // Walls
            const walls = new THREE.Mesh(
                new THREE.CylinderGeometry(9, 9, 14, 32, 1, true),
                new THREE.MeshStandardMaterial({ color: 0x3a3a4a, side: THREE.BackSide })
            );
            walls.position.y = 7;
            scene.add(walls);

            // Torches with flickering
            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2;
                const torch = new THREE.PointLight(0xff8844, 1.4, 12);
                torch.position.set(Math.cos(a) * 8, 4, Math.sin(a) * 8);
                torch.userData = { type: 'torch', baseIntensity: 0.8, flickerOffset: Math.random() * 10 };
                scene.add(torch);

                // Torch holder
                const holder = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.1, 0.6, 6),
                    new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
                );
                holder.position.set(Math.cos(a) * 8.2, 3.5, Math.sin(a) * 8.2);
                scene.add(holder);

                // Flame
                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.12, 0.35, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff6633, transparent: true, opacity: 0.9 })
                );
                flame.position.copy(torch.position);
                flame.position.y -= 0.2;
                flame.userData = { type: 'flame', baseY: flame.position.y };
                scene.add(flame);
            }

            // Central pedestal
            const pedestal = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.8, 1.8, 8),
                new THREE.MeshStandardMaterial({ color: 0x4a4a5a })
            );
            pedestal.position.y = 0.9;
            pedestal.castShadow = true;
            scene.add(pedestal);

            // Crystal
            const crystal = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.6),
                new THREE.MeshStandardMaterial({
                    color: 0x88aaff,
                    emissive: 0x4466aa,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.85
                })
            );
            crystal.position.y = 2.8;
            crystal.userData.type = 'crystal';
            scene.add(crystal);

            const crystalLight = new THREE.PointLight(0x88aaff, 3, 16);
            crystalLight.position.y = 2.8;
            scene.add(crystalLight);

            // Bookshelves along wall
            for (let i = 0; i < 4; i++) {
                const a = (i / 4) * Math.PI * 2 + Math.PI / 8;
                const shelf = new THREE.Group();

                // Shelf back
                const back = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 0.2),
                    new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
                );
                back.position.z = -0.1;
                shelf.add(back);

                // Shelves
                for (let j = 0; j < 3; j++) {
                    const shelfBoard = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.1, 0.5),
                        new THREE.MeshStandardMaterial({ color: 0x4a3a2a })
                    );
                    shelfBoard.position.y = -1 + j * 1;
                    shelfBoard.position.z = 0.15;
                    shelf.add(shelfBoard);

                    // Books
                    for (let k = 0; k < 5; k++) {
                        const bookColor = [0x8a4444, 0x44448a, 0x448a44, 0x8a8a44, 0x8a448a][Math.floor(Math.random() * 5)];
                        const book = new THREE.Mesh(
                            new THREE.BoxGeometry(0.15 + Math.random() * 0.1, 0.5 + Math.random() * 0.3, 0.3),
                            new THREE.MeshStandardMaterial({ color: bookColor })
                        );
                        book.position.set(-0.7 + k * 0.35, -0.7 + j * 1, 0.25);
                        book.rotation.z = (Math.random() - 0.5) * 0.1;
                        shelf.add(book);
                    }
                }

                shelf.position.set(Math.cos(a) * 7.5, 2, Math.sin(a) * 7.5);
                shelf.rotation.y = -a + Math.PI;
                scene.add(shelf);
            }

            // Exit portal
            const exitPortal = new THREE.Mesh(
                new THREE.CircleGeometry(1.8, 32),
                new THREE.ShaderMaterial({
                    uniforms: { time: { value: 0 } },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec2 vUv;
                        void main() {
                            vec2 c = vUv - 0.5;
                            float d = length(c);
                            float a = atan(c.y, c.x);
                            float swirl = sin(a * 4.0 - time * 1.5 + d * 6.0) * 0.5 + 0.5;
                            vec3 color = mix(vec3(0.2, 0.4, 0.3), vec3(0.3, 0.6, 0.4), swirl);
                            color += vec3(0.1, 0.3, 0.2) * smoothstep(0.5, 0.0, d);
                            float alpha = smoothstep(0.5, 0.2, d) * 0.85;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true
                })
            );
            exitPortal.rotation.x = -Math.PI / 2;
            exitPortal.position.set(6, 0.05, 0);
            exitPortal.userData.type = 'exitPortal';
            exitPortal.userData.isGround = true;
            scene.add(exitPortal);

            const exitLight = new THREE.PointLight(0x44aa66, 1.2, 6);
            exitLight.position.set(6, 0.5, 0);
            scene.add(exitLight);

            // Memory fragment in tower
            createMemoryFragment(0, 0, -5);

            // Player
            createPlayer();
            playerState.position.set(0, 1.5, 5);
            playerState.targetPosition.set(0, 1.5, 5);
            player.position.copy(playerState.position);

            camera.position.set(0, 14, 18);
            controls.target.set(0, 2, 0);

            setWhisper('the tower of memories...');
        }

        // ============================================
        // UPDATE FUNCTIONS
        // ============================================
        function updateTarget(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const grounds = scene.children.filter(c => c.userData.isGround);
            const hits = raycaster.intersectObjects(grounds, true);

            if (hits.length > 0) {
                const p = hits[0].point;
                const maxDist = currentScene === 'island' ? 15 : 8;
                const dist = Math.sqrt(p.x * p.x + p.z * p.z);
                if (dist < maxDist) {
                    playerState.targetPosition.set(p.x, 1.5, p.z);
                }
            }
        }

        function updatePlayer(delta, time) {
            playerState.position.lerp(playerState.targetPosition, delta * 3);
            player.position.copy(playerState.position);
            player.position.y += Math.sin(time * 2) * 0.08;

            // Pulse effect
            const pulse = 0.9 + Math.sin(time * 3) * 0.1;
            player.children[1].scale.setScalar(pulse);
            player.children[2].scale.setScalar(pulse * 1.1);
            playerLight.intensity = 2 + Math.sin(time * 2.5) * 0.5;

            controls.target.lerp(player.position, delta * 2);

            // Track explored areas
            const px = Math.round(player.position.x / 5);
            const pz = Math.round(player.position.z / 5);
            const areaKey = `${px},${pz}`;
            if (!world.visitedAreas.has(areaKey)) {
                world.visitedAreas.add(areaKey);
                world.explored = Math.min(1, world.visitedAreas.size / 25);
            }

            // Check portal entries
            if (currentScene === 'island') {
                mysticalElements.forEach(el => {
                    if (el.userData.type === 'castleTower') {
                        const portalPos = el.userData.portalPos;
                        const dx = player.position.x - portalPos.x;
                        const dz = player.position.z - portalPos.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        if (dist < 1.5 && !isTransitioning) {
                            transitionToScene('tower');
                        }
                    }
                });
            } else if (currentScene === 'tower') {
                scene.children.forEach(child => {
                    if (child.userData.type === 'exitPortal') {
                        const dist = player.position.distanceTo(child.position);
                        if (dist < 2 && !isTransitioning) {
                            transitionToScene('island');
                        }
                    }
                });
            }

            // Check memory fragment collection
            memoryFragments.forEach(fragment => {
                if (!fragment.userData.collected) {
                    const dist = player.position.distanceTo(fragment.position);
                    if (dist < 1.5) {
                        collectMemory(fragment);
                    }
                }
            });
        }

        function collectMemory(fragment) {
            fragment.userData.collected = true;

            const idx = memories.findIndex(m => !m.collected);
            if (idx !== -1) {
                memories[idx].collected = true;
                world.memoriesCollected++;
                showMemoryText(memories[idx].text);
                updateMemoryCounter();

                // Grow garden based on memories
                world.gardenGrowth = world.memoriesCollected / world.totalMemories;
            }

            // Fade out fragment
            fragment.children.forEach(child => {
                if (child.material) {
                    child.material.transparent = true;
                }
            });

            // Animate collection
            const startY = fragment.position.y;
            const collectAnim = () => {
                fragment.position.y += 0.05;
                fragment.children.forEach(child => {
                    if (child.material && child.material.opacity > 0) {
                        child.material.opacity -= 0.02;
                    }
                });
                if (fragment.children[0].material.opacity > 0) {
                    requestAnimationFrame(collectAnim);
                } else {
                    scene.remove(fragment);
                }
            };
            collectAnim();
        }

        function updateFlowers(delta, time) {
            flowers.forEach(flower => {
                const dist = flower.position.distanceTo(player.position);
                const targetBloom = dist < 3.5 ? 1 - dist / 3.5 : 0;
                flower.userData.bloom += (targetBloom - flower.userData.bloom) * delta * 2.5;

                const bloom = flower.userData.bloom;
                flower.userData.petalGroup.children.forEach(petal => {
                    const spread = bloom * 0.1;
                    const a = petal.userData.baseAngle;
                    petal.position.set(Math.cos(a) * (0.04 + spread), 0, Math.sin(a) * (0.04 + spread));
                    petal.material.emissiveIntensity = 0.1 + bloom * 0.5;
                });
            });
        }

        function updateCreatures(delta, time) {
            creatures.forEach((creature, i) => {
                const data = creature.userData;
                data.driftTimer -= delta;

                if (data.driftTimer <= 0) {
                    data.driftTimer = 2 + Math.random() * 4;

                    const distToPlayer = creature.position.distanceTo(player.position);

                    // Personality affects behavior
                    if (distToPlayer < 5 && data.personality > 0.5) {
                        // Curious - approach player
                        const toPlayer = player.position.clone().sub(creature.position).normalize();
                        data.driftTarget.copy(creature.position).add(toPlayer.multiplyScalar(1.5));
                    } else {
                        // Wander
                        data.driftTarget.set(
                            creature.position.x + (Math.random() - 0.5) * 4,
                            data.baseY + (Math.random() - 0.5) * 0.5,
                            creature.position.z + (Math.random() - 0.5) * 4
                        );
                    }

                    // Keep on island
                    const d = Math.sqrt(data.driftTarget.x ** 2 + data.driftTarget.z ** 2);
                    if (d > 13) {
                        data.driftTarget.x *= 13 / d;
                        data.driftTarget.z *= 13 / d;
                    }
                }

                creature.position.lerp(data.driftTarget, delta * data.speed);
                creature.position.y = data.baseY + Math.sin(time * 2 + i * 2) * 0.15;

                // Sparkle core
                if (creature.children[1]) {
                    creature.children[1].material.opacity = 0.7 + Math.sin(time * 5 + i) * 0.3;
                }
            });
        }

        function updateMysticalElements(delta, time) {
            mysticalElements.forEach(el => {
                const data = el.userData;
                const dist = el.position.distanceTo(player.position);

                if (data.type === 'hummingTree') {
                    const glow = Math.sin(time * 0.5) * 0.5 + 0.5;
                    const proximity = Math.max(0, 1 - dist / 8);
                    data.canopy.material.emissiveIntensity = 0.15 + glow * 0.1 + proximity * 0.3;
                    data.treeLight.intensity = 0.4 + glow * 0.2 + proximity * 0.4;

                    // Orbit particles
                    el.children.forEach(child => {
                        if (child.userData.orbitAngle !== undefined) {
                            child.userData.orbitAngle += delta * child.userData.orbitSpeed;
                            const a = child.userData.orbitAngle;
                            const r = child.userData.orbitRadius;
                            child.position.x = Math.cos(a) * r;
                            child.position.z = Math.sin(a) * r;
                            child.position.y = child.userData.orbitHeight + Math.sin(time * 2 + a) * 0.2;
                        }
                    });
                }

                if (data.type === 'reflectivePond') {
                    data.pond.material.uniforms.time.value = time;
                    const proximity = Math.max(0, 1 - dist / 5);
                    data.pondLight.intensity = 0.2 + proximity * 0.4;
                }

                if (data.type === 'warmStone') {
                    const pulse = Math.sin(time * 1.5) * 0.5 + 0.5;
                    const warmth = Math.max(0, 1 - dist / 4);
                    data.stone.material.emissiveIntensity = 0.2 + pulse * 0.15 + warmth * 0.4;
                    data.innerGlow.material.opacity = 0.2 + pulse * 0.15 + warmth * 0.2;
                    data.innerGlow.scale.setScalar(1 + pulse * 0.1);
                    data.light.intensity = 1 + pulse * 0.4 + warmth * 1.5;
                    data.groundGlow.material.opacity = 0.1 + pulse * 0.08 + warmth * 0.15;
                }

                if (data.type === 'castleTower') {
                    data.portal.material.uniforms.time.value = time;
                }

                if (data.type === 'dreamGarden') {
                    // Pulse seed based on growth potential
                    const seedPulse = Math.sin(time * 2) * 0.5 + 0.5;
                    data.seed.material.opacity = 0.5 + seedPulse * 0.3 + world.gardenGrowth * 0.2;
                    data.seed.rotation.y += delta * 0.5;
                    data.seedLight.intensity = 0.3 + seedPulse * 0.2 + world.gardenGrowth * 0.5;

                    // Grow plants based on memories collected
                    data.seedSpots.forEach((spot, i) => {
                        if (!spot.userData.grown && world.gardenGrowth > (i + 1) / 8) {
                            spot.userData.grown = true;
                            growGardenPlant(spot, el.position);
                        }
                    });
                }

                if (data.type === 'forgottenShore') {
                    // Animate wave ring
                    if (data.waveRing) {
                        const scale = 1 + Math.sin(time * 0.8) * 0.1;
                        data.waveRing.scale.set(scale, scale, 1);
                        data.waveRing.material.opacity = 0.15 + Math.sin(time * 0.8) * 0.05;
                    }
                }

                if (data.type === 'ancientArch') {
                    // Shimmer effect
                    const shimmerOpacity = 0.03 + Math.sin(time * 0.5) * 0.02 + Math.max(0, 1 - dist / 6) * 0.05;
                    data.shimmer.material.opacity = shimmerOpacity;
                }
            });

            // Update floating stones
            scene.children.forEach(child => {
                if (child.userData.type === 'floatingStone') {
                    child.position.y = child.userData.baseY + Math.sin(time * child.userData.bobSpeed + child.userData.bobOffset) * 0.3;
                    child.rotation.y += delta * child.userData.rotSpeed;
                }
            });

            // Update memory fragments
            memoryFragments.forEach(fragment => {
                if (!fragment.userData.collected) {
                    fragment.position.y = fragment.userData.baseY + Math.sin(time * 1.5 + fragment.userData.bobOffset) * 0.2;
                    fragment.rotation.y += delta * 0.5;
                }
            });
        }

        function growGardenPlant(spot, gardenPos) {
            const worldPos = new THREE.Vector3();
            worldPos.copy(spot.position).add(gardenPos);

            const plant = new THREE.Group();

            // Stem
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.03, 0.5, 6),
                new THREE.MeshStandardMaterial({ color: 0x3a5a3a })
            );
            stem.position.y = 0.25;
            plant.add(stem);

            // Glowing flower
            const flowerColor = [0xffaaff, 0xaaffff, 0xffffaa, 0xffaaaa][Math.floor(Math.random() * 4)];
            const flower = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8),
                new THREE.MeshBasicMaterial({ color: flowerColor, transparent: true, opacity: 0.8 })
            );
            flower.position.y = 0.55;
            plant.add(flower);

            // Light
            const light = new THREE.PointLight(flowerColor, 0.3, 2);
            light.position.y = 0.55;
            plant.add(light);

            plant.position.copy(worldPos);
            plant.scale.setScalar(0.01);

            scene.add(plant);
            gardenPlants.push(plant);

            // Grow animation
            const grow = () => {
                if (plant.scale.x < 1) {
                    plant.scale.addScalar(0.02);
                    requestAnimationFrame(grow);
                }
            };
            grow();
        }

        function updateTowerScene(delta, time) {
            // Crystal rotation and bob
            scene.children.forEach(child => {
                if (child.userData.type === 'crystal') {
                    child.rotation.y += delta * 0.4;
                    child.rotation.x = Math.sin(time * 0.5) * 0.1;
                    child.position.y = 2.8 + Math.sin(time * 1.2) * 0.15;
                }

                if (child.userData.type === 'torch') {
                    const flicker = Math.sin(time * 10 + child.userData.flickerOffset) * 0.2;
                    child.intensity = child.userData.baseIntensity + flicker;
                }

                if (child.userData.type === 'flame') {
                    child.position.y = child.userData.baseY + Math.sin(time * 8) * 0.03;
                    child.scale.y = 1 + Math.sin(time * 12) * 0.1;
                }

                if (child.userData.type === 'exitPortal') {
                    child.material.uniforms.time.value = time;
                }
            });
        }

        // ============================================
        // ORBIT SCENE - The floating island world from space
        // ============================================
        function buildOrbitScene() {
            flowers = [];
            creatures = [];
            mysticalElements = [];
            memoryFragments = [];
            gardenPlants = [];

            scene.fog = null;
            renderer.setClearColor(0x050510);

            // Stars - bright alien constellations
            const starGeom = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];

            for (let i = 0; i < 4000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 400 + Math.random() * 300;

                starPositions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)
                );

                const c = Math.random();
                if (c < 0.4) starColors.push(1, 1, 1);
                else if (c < 0.6) starColors.push(0.8, 0.9, 1);
                else if (c < 0.8) starColors.push(1, 0.8, 1);
                else starColors.push(0.7, 1, 0.95);
            }

            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeom.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

            const stars = new THREE.Points(
                starGeom,
                new THREE.PointsMaterial({ size: 2, vertexColors: true })
            );
            scene.add(stars);

            // THE FLOATING ISLAND - Built to match the ground scene
            const worldGroup = new THREE.Group();
            worldGroup.userData.type = 'world';

            // Main island base - irregular rocky shape
            const baseGeom = new THREE.CylinderGeometry(12, 8, 6, 8, 1);
            // Distort vertices for organic look
            const basePos = baseGeom.attributes.position;
            for (let i = 0; i < basePos.count; i++) {
                const x = basePos.getX(i);
                const y = basePos.getY(i);
                const z = basePos.getZ(i);
                const noise = Math.sin(x * 0.5) * Math.cos(z * 0.5) * 1.5;
                basePos.setX(i, x + noise * 0.3);
                basePos.setZ(i, z + noise * 0.3);
            }
            baseGeom.computeVertexNormals();

            const islandBase = new THREE.Mesh(
                baseGeom,
                new THREE.MeshStandardMaterial({
                    color: 0x5a4a3a,
                    roughness: 1,
                    flatShading: true
                })
            );
            islandBase.position.y = -2;
            worldGroup.add(islandBase);

            // Grass top - bright green
            const grassTop = new THREE.Mesh(
                new THREE.CircleGeometry(12, 32),
                new THREE.MeshStandardMaterial({ color: 0x4a8a4a, roughness: 0.8 })
            );
            grassTop.rotation.x = -Math.PI / 2;
            grassTop.position.y = 1;
            worldGroup.add(grassTop);

            // TOWER - The castle tower, clearly visible
            const towerGroup = new THREE.Group();

            // Tower base
            const towerBase = new THREE.Mesh(
                new THREE.CylinderGeometry(1.8, 2.2, 6, 8),
                new THREE.MeshStandardMaterial({ color: 0x6a6a7a, roughness: 0.7 })
            );
            towerBase.position.y = 4;
            towerGroup.add(towerBase);

            // Tower top/roof
            const towerRoof = new THREE.Mesh(
                new THREE.ConeGeometry(2.2, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x4a3a5a, roughness: 0.6 })
            );
            towerRoof.position.y = 8;
            towerGroup.add(towerRoof);

            // Tower glow (portal light from window)
            const towerGlow = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0x6688ff, transparent: true, opacity: 0.8 })
            );
            towerGlow.position.set(0, 5, 1.8);
            towerGroup.add(towerGlow);

            towerGroup.position.set(4, 0, 3);
            worldGroup.add(towerGroup);

            // ANCIENT TREE - Glowing green
            const treeGroup = new THREE.Group();

            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.6, 3, 6),
                new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
            );
            trunk.position.y = 2.5;
            treeGroup.add(trunk);

            const foliage = new THREE.Mesh(
                new THREE.SphereGeometry(2.5, 8, 8),
                new THREE.MeshStandardMaterial({
                    color: 0x2a5a2a,
                    emissive: 0x225522,
                    emissiveIntensity: 0.5
                })
            );
            foliage.position.y = 5;
            foliage.scale.y = 0.8;
            treeGroup.add(foliage);

            // Tree glow
            const treeLight = new THREE.PointLight(0x44ff44, 1, 15);
            treeLight.position.y = 5;
            treeGroup.add(treeLight);

            treeGroup.position.set(-4, 0, -2);
            worldGroup.add(treeGroup);

            // POND - Glowing purple water
            const pond = new THREE.Mesh(
                new THREE.CircleGeometry(2, 16),
                new THREE.MeshBasicMaterial({ color: 0x4444aa, transparent: true, opacity: 0.8 })
            );
            pond.rotation.x = -Math.PI / 2;
            pond.position.set(-2, 1.1, 4);
            worldGroup.add(pond);

            const pondGlow = new THREE.PointLight(0x6644aa, 0.8, 8);
            pondGlow.position.set(-2, 2, 4);
            worldGroup.add(pondGlow);

            // SHORE area with sand
            const shore = new THREE.Mesh(
                new THREE.PlaneGeometry(6, 4),
                new THREE.MeshStandardMaterial({ color: 0x9a8a6a, roughness: 1 })
            );
            shore.rotation.x = -Math.PI / 2;
            shore.position.set(8, 1.05, -4);
            shore.rotation.z = 0.3;
            worldGroup.add(shore);

            // PLAYER LIGHT ORB - glowing on the island
            const playerOrb = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xaaccff })
            );
            playerOrb.position.set(0, 2, 0);
            worldGroup.add(playerOrb);

            const playerGlow = new THREE.PointLight(0xaaccff, 1.5, 10);
            playerGlow.position.set(0, 2, 0);
            worldGroup.add(playerGlow);

            // Soft glow ring around island edge
            const glowRing = new THREE.Mesh(
                new THREE.TorusGeometry(14, 2, 8, 32),
                new THREE.MeshBasicMaterial({
                    color: 0x6699cc,
                    transparent: true,
                    opacity: 0.2
                })
            );
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 0;
            worldGroup.add(glowRing);

            // Subtle rocky underside - not a dark blob
            const underside = new THREE.Mesh(
                new THREE.ConeGeometry(8, 5, 8),
                new THREE.MeshStandardMaterial({
                    color: 0x4a3a2a,
                    roughness: 1,
                    flatShading: true
                })
            );
            underside.rotation.x = Math.PI;
            underside.position.y = -5;
            worldGroup.add(underside);

            scene.add(worldGroup);

            // Bright lighting
            const sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(30, 40, 30);
            scene.add(sunLight);

            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.8);
            fillLight.position.set(-20, 10, -20);
            scene.add(fillLight);

            scene.add(new THREE.AmbientLight(0x667788, 1.2));

            // Camera position - good view of the island
            camera.position.set(25, 20, 35);
            camera.lookAt(0, 0, 0);
            camera.fov = 50;
            camera.updateProjectionMatrix();

            controls.target.set(0, 0, 0);
            controls.minDistance = 25;
            controls.maxDistance = 150;
            controls.enabled = true;

            setWhisper('the in-between... adrift in the void...');

            setTimeout(() => {
                setWhisper('scroll to see the system...');
            }, 4000);
        }

        // ============================================
        // SOLAR SYSTEM SCENE - Alien Level 2 Civilization
        // ============================================
        function buildSolarSystemScene() {
            flowers = [];
            creatures = [];
            mysticalElements = [];
            memoryFragments = [];
            gardenPlants = [];

            scene.fog = null;
            renderer.setClearColor(0x050508);

            // Alien stars - different colors
            const starGeom = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            for (let i = 0; i < 6000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = 1500 + Math.random() * 1500;

                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.cos(phi),
                    r * Math.sin(phi) * Math.sin(theta)
                );

                const c = Math.random();
                if (c < 0.3) colors.push(0.9, 0.85, 1);
                else if (c < 0.5) colors.push(0.7, 0.9, 1);
                else if (c < 0.7) colors.push(1, 0.8, 0.9);
                else if (c < 0.85) colors.push(0.8, 1, 0.85);
                else colors.push(1, 0.6, 0.5);
            }

            starGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const stars = new THREE.Points(
                starGeom,
                new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent: true, opacity: 0.9 })
            );
            scene.add(stars);

            // ALIEN STAR - Larger, purple-white with energy collection structures
            const starGroup = new THREE.Group();
            starGroup.userData.type = 'star';

            const star = new THREE.Mesh(
                new THREE.SphereGeometry(40, 32, 32),
                new THREE.ShaderMaterial({
                    uniforms: { time: { value: 0 } },
                    vertexShader: `
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        void main() {
                            vUv = uv;
                            vNormal = normal;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        void main() {
                            vec2 c = vUv - 0.5;
                            float d = length(c);
                            float pulse = sin(time * 2.0 + d * 10.0) * 0.5 + 0.5;
                            // Purple-white alien star
                            vec3 core = vec3(1.0, 0.95, 1.0);
                            vec3 mid = vec3(0.9, 0.7, 1.0);
                            vec3 corona = vec3(0.6, 0.4, 0.8);
                            vec3 color = mix(core, mid, d * 1.5);
                            color = mix(color, corona, d * 2.0 + pulse * 0.1);
                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                })
            );
            starGroup.add(star);

            // Star corona glow
            const corona = new THREE.Mesh(
                new THREE.SphereGeometry(55, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: 0xaa88ff,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                })
            );
            starGroup.add(corona);

            // DYSON SWARM - Level 2 civilization energy collectors
            const dysonSwarm = new THREE.Group();
            dysonSwarm.userData.type = 'dysonSwarm';

            // Ring of collectors
            for (let ring = 0; ring < 3; ring++) {
                const ringRadius = 70 + ring * 25;
                const collectorCount = 20 + ring * 10;

                for (let i = 0; i < collectorCount; i++) {
                    const angle = (i / collectorCount) * Math.PI * 2;

                    // Solar collector - hexagonal panels
                    const collector = new THREE.Mesh(
                        new THREE.CircleGeometry(3 + Math.random() * 2, 6),
                        new THREE.MeshBasicMaterial({
                            color: 0x4466aa,
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.DoubleSide
                        })
                    );

                    const tilt = (Math.random() - 0.5) * 0.5;
                    collector.position.set(
                        Math.cos(angle) * ringRadius,
                        Math.sin(tilt) * ringRadius * 0.3,
                        Math.sin(angle) * ringRadius
                    );
                    collector.lookAt(0, 0, 0);

                    collector.userData = {
                        type: 'collector',
                        orbitAngle: angle,
                        orbitRadius: ringRadius,
                        orbitTilt: tilt,
                        orbitSpeed: 0.02 / (ring + 1)
                    };

                    dysonSwarm.add(collector);
                }

                // Energy beam ring (visual)
                const beamRing = new THREE.Mesh(
                    new THREE.TorusGeometry(ringRadius, 0.5, 8, 64),
                    new THREE.MeshBasicMaterial({
                        color: 0x88aaff,
                        transparent: true,
                        opacity: 0.2
                    })
                );
                beamRing.rotation.x = Math.PI / 2;
                dysonSwarm.add(beamRing);
            }

            scene.add(starGroup);
            scene.add(dysonSwarm);

            // Star light
            const starLight = new THREE.PointLight(0xeeddff, 3, 2000);
            scene.add(starLight);

            // PLANETS - Alien worlds
            const alienPlanets = [
                { name: 'cinder', radius: 5, distance: 130, color: 0x553322, speed: 0.015, glow: 0xff4400 },
                { name: 'veil', radius: 8, distance: 180, color: 0x886688, speed: 0.01, hasRings: true, ringColor: 0xaa99bb },
                { name: 'sanctuary', radius: 7, distance: 250, color: 0x446655, speed: 0.007, isHome: true }, // Our world
                { name: 'drift', radius: 12, distance: 350, color: 0x445566, speed: 0.004, hasMoons: 3 },
                { name: 'sentinel', radius: 18, distance: 500, color: 0x554455, speed: 0.002, hasRings: true, ringColor: 0x665577 },
                { name: 'wanderer', radius: 6, distance: 700, color: 0x334455, speed: 0.001 }
            ];

            alienPlanets.forEach(p => {
                const planetGroup = new THREE.Group();

                const planet = new THREE.Mesh(
                    new THREE.SphereGeometry(p.radius, 24, 24),
                    new THREE.MeshStandardMaterial({
                        color: p.color,
                        roughness: 0.8,
                        metalness: 0.1
                    })
                );
                planetGroup.add(planet);

                // Volcanic glow
                if (p.glow) {
                    const glowMesh = new THREE.Mesh(
                        new THREE.SphereGeometry(p.radius * 1.05, 16, 16),
                        new THREE.MeshBasicMaterial({
                            color: p.glow,
                            transparent: true,
                            opacity: 0.3
                        })
                    );
                    planetGroup.add(glowMesh);
                }

                // Rings
                if (p.hasRings) {
                    const rings = new THREE.Mesh(
                        new THREE.RingGeometry(p.radius * 1.5, p.radius * 2.5, 64),
                        new THREE.MeshBasicMaterial({
                            color: p.ringColor,
                            transparent: true,
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        })
                    );
                    rings.rotation.x = Math.PI / 2.5;
                    planetGroup.add(rings);
                }

                // Multiple moons
                if (p.hasMoons) {
                    for (let m = 0; m < p.hasMoons; m++) {
                        const moon = new THREE.Mesh(
                            new THREE.SphereGeometry(1 + Math.random(), 8, 8),
                            new THREE.MeshStandardMaterial({ color: 0x666666 })
                        );
                        const moonDist = p.radius * 2 + m * 4;
                        moon.position.set(moonDist, 0, 0);
                        moon.userData = { type: 'moon', orbitAngle: Math.random() * Math.PI * 2, orbitRadius: moonDist };
                        planetGroup.add(moon);
                    }
                }

                // Home world marker
                if (p.isHome) {
                    const marker = new THREE.Mesh(
                        new THREE.SphereGeometry(p.radius * 1.3, 16, 16),
                        new THREE.MeshBasicMaterial({
                            color: 0x88aaff,
                            transparent: true,
                            opacity: 0.15
                        })
                    );
                    planetGroup.add(marker);

                    // The floating island on this world
                    const tinyIsland = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.5, 0),
                        new THREE.MeshBasicMaterial({ color: 0x5a7a5a })
                    );
                    tinyIsland.position.set(0, p.radius + 1, 0);
                    tinyIsland.userData.type = 'tinyIsland';
                    planetGroup.add(tinyIsland);
                }

                const angle = Math.random() * Math.PI * 2;
                planetGroup.position.set(
                    Math.cos(angle) * p.distance,
                    (Math.random() - 0.5) * 30,
                    Math.sin(angle) * p.distance
                );

                planetGroup.userData = {
                    type: 'alienPlanet',
                    name: p.name,
                    orbitRadius: p.distance,
                    orbitAngle: angle,
                    orbitSpeed: p.speed,
                    isHome: p.isHome
                };

                scene.add(planetGroup);

                // Faint orbit path
                const orbitPath = new THREE.Mesh(
                    new THREE.RingGeometry(p.distance - 1, p.distance + 1, 128),
                    new THREE.MeshBasicMaterial({
                        color: 0x333344,
                        transparent: true,
                        opacity: 0.1,
                        side: THREE.DoubleSide
                    })
                );
                orbitPath.rotation.x = Math.PI / 2;
                scene.add(orbitPath);
            });

            scene.add(new THREE.AmbientLight(0x445566, 0.6));

            // Camera
            camera.position.set(200, 150, 400);
            camera.lookAt(0, 0, 0);
            camera.fov = 60;
            camera.updateProjectionMatrix();

            controls.target.set(0, 0, 0);
            controls.minDistance = 80;
            controls.maxDistance = 1200;
            controls.enabled = true;

            setWhisper('the system... harnessing the star...');

            setTimeout(() => {
                setWhisper('scroll down to return...');
            }, 5000);
        }

        function updateOrbitScene(delta, time) {
            scene.children.forEach(child => {
                if (child.userData.type === 'world') {
                    child.rotation.y += delta * 0.15;
                }
            });
        }

        function updateSolarScene(delta, time) {
            scene.children.forEach(child => {
                // Animate star
                if (child.userData.type === 'star') {
                    child.children.forEach(c => {
                        if (c.material && c.material.uniforms) {
                            c.material.uniforms.time.value = time;
                        }
                    });
                }

                // Animate Dyson swarm
                if (child.userData.type === 'dysonSwarm') {
                    child.children.forEach(collector => {
                        if (collector.userData.type === 'collector') {
                            collector.userData.orbitAngle += collector.userData.orbitSpeed * delta;
                            const a = collector.userData.orbitAngle;
                            const r = collector.userData.orbitRadius;
                            const tilt = collector.userData.orbitTilt;
                            collector.position.set(
                                Math.cos(a) * r,
                                Math.sin(tilt + time * 0.1) * r * 0.3,
                                Math.sin(a) * r
                            );
                            collector.lookAt(0, 0, 0);
                        }
                    });
                    child.rotation.y += delta * 0.02;
                }

                // Animate planets
                if (child.userData.type === 'alienPlanet') {
                    child.userData.orbitAngle += child.userData.orbitSpeed * delta;
                    const a = child.userData.orbitAngle;
                    const r = child.userData.orbitRadius;
                    child.position.x = Math.cos(a) * r;
                    child.position.z = Math.sin(a) * r;

                    // Rotate planet
                    child.children[0].rotation.y += delta * 0.3;

                    // Animate moons
                    child.children.forEach(c => {
                        if (c.userData.type === 'moon') {
                            c.userData.orbitAngle += delta * 1.5;
                            const ma = c.userData.orbitAngle;
                            const mr = c.userData.orbitRadius;
                            c.position.set(Math.cos(ma) * mr, 0, Math.sin(ma) * mr);
                        }
                        if (c.userData.type === 'tinyIsland') {
                            c.rotation.y += delta * 0.5;
                            c.position.y = child.children[0].geometry.parameters.radius + 1 + Math.sin(time * 2) * 0.2;
                        }
                    });
                }
            });
        }

        function transitionToScene(targetScene) {
            if (isTransitioning) return;
            isTransitioning = true;

            const overlay = document.getElementById('fade-overlay');

            // All transitions are black
            overlay.style.background = 'black';

            overlay.style.opacity = '1';

            setTimeout(() => {
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }

                if (targetScene === 'tower') {
                    buildTowerScene();
                    currentScene = 'tower';
                } else if (targetScene === 'orbit') {
                    buildOrbitScene();
                    currentScene = 'orbit';
                } else if (targetScene === 'solar') {
                    buildSolarSystemScene();
                    currentScene = 'solar';
                } else {
                    buildIslandScene();
                    currentScene = 'island';
                    currentZoomLevel = 2;
                    targetZoom = zoomLevels[2];
                    currentZoomState = { ...zoomLevels[2] };
                    setWhisper('returned to the in-between...');
                }

                setTimeout(() => {
                    overlay.style.opacity = '0';
                    isTransitioning = false;
                }, 500);
            }, 1500);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // Update sky/stars
            scene.children.forEach(child => {
                if (child.userData.type === 'sky') {
                    child.material.uniforms.time.value = time;
                    child.material.uniforms.atmosphere.value = world.explored * 0.3;
                }
                if (child.userData.type === 'stars') {
                    child.material.uniforms.time.value = time;
                }
                if (child.userData.type === 'water') {
                    child.material.uniforms.time.value = time;
                }
            });

            updatePlayer(delta, time);

            if (currentScene === 'island') {
                updateFlowers(delta, time);
                updateCreatures(delta, time);
                updateMysticalElements(delta, time);
                updateZoom(delta);
                applyZoomToCamera();
            } else if (currentScene === 'tower') {
                updateTowerScene(delta, time);
                updateMysticalElements(delta, time);
            } else if (currentScene === 'orbit') {
                updateOrbitScene(delta, time);
            } else if (currentScene === 'solar') {
                updateSolarScene(delta, time);
            }

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
